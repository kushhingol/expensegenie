// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.33.2
// source: template.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "./google/protobuf/timestamp";

export enum FieldType {
  FIELD_TYPE_UNSPECIFIED = 0,
  /** AMOUNT - Numeric */
  AMOUNT = 1,
  NUMBER = 2,
  PERCENTAGE = 3,
  /** TEXT - Text */
  TEXT = 4,
  TEXTAREA = 5,
  EMAIL = 6,
  PHONE = 7,
  URL = 8,
  /** DATE - Date */
  DATE = 9,
  DATETIME = 10,
  MONTH_YEAR = 11,
  /** DROPDOWN - Selection */
  DROPDOWN = 12,
  MULTI_SELECT = 13,
  RADIO = 14,
  CHECKBOX = 15,
  /** CATEGORY - Expense specific */
  CATEGORY = 16,
  PAYMENT_MODE = 17,
  CURRENCY = 18,
  TAX_AMOUNT = 19,
  TAX_NUMBER = 20,
  INVOICE_NUMBER = 21,
  MERCHANT = 22,
  /** FILE - Files */
  FILE = 23,
  IMAGE = 24,
  RECEIPT = 25,
  /** LOCATION - Location / travel */
  LOCATION = 26,
  DISTANCE = 27,
  /** BOOLEAN - Boolean / system */
  BOOLEAN = 28,
  AUTO_GENERATED = 29,
  UNRECOGNIZED = -1,
}

export function fieldTypeFromJSON(object: any): FieldType {
  switch (object) {
    case 0:
    case "FIELD_TYPE_UNSPECIFIED":
      return FieldType.FIELD_TYPE_UNSPECIFIED;
    case 1:
    case "AMOUNT":
      return FieldType.AMOUNT;
    case 2:
    case "NUMBER":
      return FieldType.NUMBER;
    case 3:
    case "PERCENTAGE":
      return FieldType.PERCENTAGE;
    case 4:
    case "TEXT":
      return FieldType.TEXT;
    case 5:
    case "TEXTAREA":
      return FieldType.TEXTAREA;
    case 6:
    case "EMAIL":
      return FieldType.EMAIL;
    case 7:
    case "PHONE":
      return FieldType.PHONE;
    case 8:
    case "URL":
      return FieldType.URL;
    case 9:
    case "DATE":
      return FieldType.DATE;
    case 10:
    case "DATETIME":
      return FieldType.DATETIME;
    case 11:
    case "MONTH_YEAR":
      return FieldType.MONTH_YEAR;
    case 12:
    case "DROPDOWN":
      return FieldType.DROPDOWN;
    case 13:
    case "MULTI_SELECT":
      return FieldType.MULTI_SELECT;
    case 14:
    case "RADIO":
      return FieldType.RADIO;
    case 15:
    case "CHECKBOX":
      return FieldType.CHECKBOX;
    case 16:
    case "CATEGORY":
      return FieldType.CATEGORY;
    case 17:
    case "PAYMENT_MODE":
      return FieldType.PAYMENT_MODE;
    case 18:
    case "CURRENCY":
      return FieldType.CURRENCY;
    case 19:
    case "TAX_AMOUNT":
      return FieldType.TAX_AMOUNT;
    case 20:
    case "TAX_NUMBER":
      return FieldType.TAX_NUMBER;
    case 21:
    case "INVOICE_NUMBER":
      return FieldType.INVOICE_NUMBER;
    case 22:
    case "MERCHANT":
      return FieldType.MERCHANT;
    case 23:
    case "FILE":
      return FieldType.FILE;
    case 24:
    case "IMAGE":
      return FieldType.IMAGE;
    case 25:
    case "RECEIPT":
      return FieldType.RECEIPT;
    case 26:
    case "LOCATION":
      return FieldType.LOCATION;
    case 27:
    case "DISTANCE":
      return FieldType.DISTANCE;
    case 28:
    case "BOOLEAN":
      return FieldType.BOOLEAN;
    case 29:
    case "AUTO_GENERATED":
      return FieldType.AUTO_GENERATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldType.UNRECOGNIZED;
  }
}

export function fieldTypeToJSON(object: FieldType): string {
  switch (object) {
    case FieldType.FIELD_TYPE_UNSPECIFIED:
      return "FIELD_TYPE_UNSPECIFIED";
    case FieldType.AMOUNT:
      return "AMOUNT";
    case FieldType.NUMBER:
      return "NUMBER";
    case FieldType.PERCENTAGE:
      return "PERCENTAGE";
    case FieldType.TEXT:
      return "TEXT";
    case FieldType.TEXTAREA:
      return "TEXTAREA";
    case FieldType.EMAIL:
      return "EMAIL";
    case FieldType.PHONE:
      return "PHONE";
    case FieldType.URL:
      return "URL";
    case FieldType.DATE:
      return "DATE";
    case FieldType.DATETIME:
      return "DATETIME";
    case FieldType.MONTH_YEAR:
      return "MONTH_YEAR";
    case FieldType.DROPDOWN:
      return "DROPDOWN";
    case FieldType.MULTI_SELECT:
      return "MULTI_SELECT";
    case FieldType.RADIO:
      return "RADIO";
    case FieldType.CHECKBOX:
      return "CHECKBOX";
    case FieldType.CATEGORY:
      return "CATEGORY";
    case FieldType.PAYMENT_MODE:
      return "PAYMENT_MODE";
    case FieldType.CURRENCY:
      return "CURRENCY";
    case FieldType.TAX_AMOUNT:
      return "TAX_AMOUNT";
    case FieldType.TAX_NUMBER:
      return "TAX_NUMBER";
    case FieldType.INVOICE_NUMBER:
      return "INVOICE_NUMBER";
    case FieldType.MERCHANT:
      return "MERCHANT";
    case FieldType.FILE:
      return "FILE";
    case FieldType.IMAGE:
      return "IMAGE";
    case FieldType.RECEIPT:
      return "RECEIPT";
    case FieldType.LOCATION:
      return "LOCATION";
    case FieldType.DISTANCE:
      return "DISTANCE";
    case FieldType.BOOLEAN:
      return "BOOLEAN";
    case FieldType.AUTO_GENERATED:
      return "AUTO_GENERATED";
    case FieldType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Template {
  userId: string;
  name: string;
  isPublic: boolean;
  createdAt?: Date | undefined;
  customFields: CustomFields[];
  isDeleted: boolean;
}

export interface CustomFields {
  label: string;
  type: FieldType;
  options: string[];
  required: boolean;
}

function createBaseTemplate(): Template {
  return { userId: "", name: "", isPublic: false, createdAt: undefined, customFields: [], isDeleted: false };
}

export const Template: MessageFns<Template> = {
  encode(message: Template, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.isPublic !== false) {
      writer.uint32(24).bool(message.isPublic);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).join();
    }
    for (const v of message.customFields) {
      CustomFields.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.isDeleted !== false) {
      writer.uint32(48).bool(message.isDeleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Template {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isPublic = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.customFields.push(CustomFields.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isDeleted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Template {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      isPublic: isSet(object.isPublic) ? globalThis.Boolean(object.isPublic) : false,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      customFields: globalThis.Array.isArray(object?.customFields)
        ? object.customFields.map((e: any) => CustomFields.fromJSON(e))
        : [],
      isDeleted: isSet(object.isDeleted) ? globalThis.Boolean(object.isDeleted) : false,
    };
  },

  toJSON(message: Template): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.isPublic !== false) {
      obj.isPublic = message.isPublic;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.customFields?.length) {
      obj.customFields = message.customFields.map((e) => CustomFields.toJSON(e));
    }
    if (message.isDeleted !== false) {
      obj.isDeleted = message.isDeleted;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Template>, I>>(base?: I): Template {
    return Template.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Template>, I>>(object: I): Template {
    const message = createBaseTemplate();
    message.userId = object.userId ?? "";
    message.name = object.name ?? "";
    message.isPublic = object.isPublic ?? false;
    message.createdAt = object.createdAt ?? undefined;
    message.customFields = object.customFields?.map((e) => CustomFields.fromPartial(e)) || [];
    message.isDeleted = object.isDeleted ?? false;
    return message;
  },
};

function createBaseCustomFields(): CustomFields {
  return { label: "", type: 0, options: [], required: false };
}

export const CustomFields: MessageFns<CustomFields> = {
  encode(message: CustomFields, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    for (const v of message.options) {
      writer.uint32(26).string(v!);
    }
    if (message.required !== false) {
      writer.uint32(32).bool(message.required);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomFields {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomFields();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.options.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomFields {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      type: isSet(object.type) ? fieldTypeFromJSON(object.type) : 0,
      options: globalThis.Array.isArray(object?.options) ? object.options.map((e: any) => globalThis.String(e)) : [],
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
    };
  },

  toJSON(message: CustomFields): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.type !== 0) {
      obj.type = fieldTypeToJSON(message.type);
    }
    if (message.options?.length) {
      obj.options = message.options;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomFields>, I>>(base?: I): CustomFields {
    return CustomFields.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomFields>, I>>(object: I): CustomFields {
    const message = createBaseCustomFields();
    message.label = object.label ?? "";
    message.type = object.type ?? 0;
    message.options = object.options?.map((e) => e) || [];
    message.required = object.required ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
